% Semi-Supervised Learning with Particle Competition and Cooperation
% by Fabricio Breve - 21/01/2019
%
% If you use this algorithm, please cite:
% Breve, Fabricio Aparecido; Zhao, Liang; Quiles, Marcos Gonçalves;
% Pedrycz, Witold; Liu, Jiming, "Particle Competition and Cooperation in
% Networks for Semi-Supervised Learning," Knowledge and Data Engineering,
% IEEE Transactions on , vol.24, no.9, pp.1686,1698, Sept. 2012.
% doi: 10.1109/TKDE.2011.119
%
% Usage: [owner, pot, owndeg, distnode] = pcc(X, slabel, options)
% INPUT:
% X         - Matrix where each line is a data item and each column is an
%             attribute
% slabel    - Vector where each element is the label of the corresponding
%             data item in X (use 1,2,3,... for labeled data items and 0
%             for unlabeled data items)
% OPTIONS:
% k         - Each node is connected to its k-neirest neighbors. Default:
%             size of the dataset multiplied by 0.05.
% disttype  - Use 'euclidean', 'seuclidean', etc. Default: 'euclidean'
% valpha    - Lower it to stop earlier, accuracy may be lower. Default:
%             2000.
% pgrd      - Check p_grd in [1]. Default: 0.5.
% deltav    - Check delta_v in [1]. Default: 0.1
% deltap    - Default: 1 (leave it on default to match equations in [1])
% dexp      - Default: 2 (leave it on default to match equations in [1])
% nclass    - Amount of classes on the problem. Default is the highest
%             label number in slabel.
% maxiter   - Maximum amount of iterations. Default is 500,000.
% mex       - Uses the mex version of the code (compiled binary) which is
%             ~10 times faster. Default: true. Set to false to use the 
%             Matlab only version.
% seed      - If seed is a nonnegative integer, it will be used to itialize
%             the random number generator, which is rng() or rand_s() 
%             in non-mex and mex versions, respectively. Use a seed if you
%             want reproducible results.
%
% OUTPUT:
% owner     - vector of classes assigned to each data item
% owndeg    - fuzzy output as in [2], each line is a data item, each column
%             pertinence to a class
% distnode  - matrix with the distance vectors of each particle, each
%             column is a particle and each line is a node
%
% [1] Breve, Fabricio Aparecido; Zhao, Liang; Quiles, Marcos Gonçalves;
% Pedrycz, Witold; Liu, Jiming, "Particle Competition and Cooperation in
% Networks for Semi-Supervised Learning," Knowledge and Data Engineering,
% IEEE Transactions on , vol.24, no.9, pp.1686,1698, Sept. 2012.
% doi: 10.1109/TKDE.2011.119
%
% [2] Breve, Fabricio Aparecido; ZHAO, Liang. 
% "Fuzzy community structure detection by particle competition and cooperation."
% Soft Computing (Berlin. Print). , v.17, p.659 - 673, 2013.

function [owner, pot, owndeg, distnode] = pcc(X, slabel, options)
    arguments
        X double
        slabel uint16
        options.k uint16 = size(X,1)*0.05
        options.disttype string = 'euclidean'
        options.valpha double = 2000
        options.pgrd double = 0.500 % probability of taking the greedy movement
        options.deltav double = 0.100 % controls node domination levels increase/decrease rate
        options.deltap double = 1.000 % controls particle potential increase/decrease rate
        options.dexp double = 2 % probabilities exponential
        options.nclass uint16 = max(slabel) % quantity of classes
        options.maxiter uint32 = 500000 % maximum amount of iterations
        options.mex logical = true % uses the mex version
        options.seed int32 = -1 % random seed
    end     

    % constants
    potmax = 1.000; % potencial máximo
    potmin = 0.000; % potencial mínimo
    npart = sum(slabel~=0); % quantidade de partículas
    qtnode = size(X,1);
    stopmax = round((qtnode/(npart*options.k))*round(options.valpha*0.1)); % qtde de iterações para verificar convergência    
    % normalizar atributos se necessário
    if strcmp(options.disttype,'seuclidean')==1
        X = zscore(X);
        options.disttype='euclidean';
    end
    % encontrando k-vizinhos mais próximos      
    KNN = uint32(knnsearch(X,X,'K',options.k+1,'NSMethod','kdtree','Distance',options.disttype));
    KNN = KNN(:,2:end); % eliminando o elemento como vizinho de si mesmo
    KNN(:,end+1:end+options.k) = 0;
    knns = repmat(options.k,qtnode,1); % vetor com a quantidade de vizinhos de cada nó       
    for i=1:qtnode
        KNN(sub2ind(size(KNN),KNN(i,1:options.k),(knns(KNN(i,1:options.k))+1)'))=i; % adicionando i como vizinho dos vizinhos de i (criando reciprocidade)
        knns(KNN(i,1:options.k))=knns(KNN(i,1:options.k))+1; % aumentando contador de vizinhos nos nós que tiveram vizinhos adicionados
        if max(knns)==size(KNN,2) % se algum nó atingiu o limite de colunas da matriz de vizinhança recíproca teremos de aumentá-la
            KNN(:,max(knns)+1:round(max(knns)*1.1)+1) = zeros(qtnode,round(max(knns)*0.1)+1,'uint32');  % portanto vamos aumenta-la em 10% + 1 (para garantir no caso do tamanho ser menor que 10)            
        end
    end
    % removendo duplicatas    
    for i=1:qtnode
        knnrow = unique(KNN(i,:),'stable'); % remove as duplicatas
        knns(i) = size(knnrow,2)-1; % atualiza quantidade de vizinhos (e descarta o zero no final)
        KNN(i,1:knns(i)) = knnrow(1:end-1); % copia para matriz KNN
        %KNN(i,knns(i)+1:end) = 0; % preenche espaços não usados por zero,
        %apenas para debug pois na prática não faz diferença visto que knns
        %já dirá quais são os vizinhos válidos da lista
    end    
    KNN = KNN(:,1:max(knns)); % eliminando colunas que não tem vizinhos válidos
    % definindo classe de cada partícula
    partclass = slabel(slabel~=0);
    % definindo nó casa da partícula
    partnode = uint32(find(slabel));
    % definindo potencial da partícula em 1
    potpart = ones(potmax,npart);       
    % ajustando todas as distâncias na máxima possível
    distnode = repmat(min(intmax('uint8'),uint8(qtnode-1)),qtnode,npart);
    % ajustando para zero a distância de cada partícula para seu
    % respectivo nó casa
    distnode(sub2ind(size(distnode),partnode',1:npart)) = 0;
    % inicializando tabela de potenciais com tudo igual
    pot = repmat(potmax/double(options.nclass),qtnode,options.nclass);
    % zerando potenciais dos nós rotulados
    pot(partnode,:) = 0;
    % ajustando potencial da classe respectiva do nó rotulado para 1
    pot(sub2ind(size(pot),partnode,slabel(partnode))) = 1;
    % colocando cada nó em sua casa
    partpos = partnode;           
    % definindo grau de propriedade
    owndeg = repmat(realmin,qtnode,options.nclass);  % não podemos usar 0, porque nós não visitados dariam divisão por 0
    
    if options.mex==true    
        pccloop(options.maxiter, npart, options.nclass, stopmax, options.pgrd, ...
            options.dexp, options.deltav, options.deltap, potmin, partnode, ... 
            partclass, potpart, slabel, knns, distnode, KNN, pot, owndeg, options.seed);
    else
        % if a seed was provided in the options, use it.
        if options.seed>0
            rng(options.seed)
        end
        % variável para guardar máximo potencial mais alto médio
        maxmmpot = 0;
        % counter of how much times the stop criterion checked positive
        stopcnt = 0;
        for i=1:options.maxiter
            % para cada partícula
            rndtb = unifrnd(0,1,npart,1);  % probabilidade pdet
            roulettepick = unifrnd(0,1,npart,1);  % sorteio da roleta
            for j=1:npart
                ppj = partpos(j);
                if rndtb(j)<options.pgrd
                    % regra de probabilidade
                    prob = cumsum((1./(1+double(distnode(KNN(ppj,1:knns(ppj)),j))).^options.dexp)'.* pot(KNN(ppj,1:knns(ppj)),partclass(j))');
                    % descobrindo quem foi o nó sorteado
                    k = KNN(ppj,find(prob>=(roulettepick(j)*prob(end)),1,'first'));
                else
                    k = KNN(ppj,ceil(roulettepick(j)*double(knns(ppj))));
                    % contador de visita (para calcular grau de propriedade)
                    owndeg(k,partclass(j)) = owndeg(k,partclass(j)) + potpart(j);
                end           
                % se o nó não é pré-rotulado
                if slabel(k)==0
                    % calculando novos potenciais para nó
                    deltapotpart = pot(k,:) - max(potmin,pot(k,:) - potpart(j)*(options.deltav/(double(options.nclass)-1)));
                    pot(k,:) = pot(k,:) - deltapotpart;
                    pot(k,partclass(j)) = pot(k,partclass(j)) + sum(deltapotpart);
                end
                % atribui novo potencial para partícula
                potpart(j) = potpart(j) + (pot(k,partclass(j))-potpart(j))*options.deltap;
                          
                % se distância do nó alvo maior que distância do nó atual + 1
                if distnode(partpos(j),j)+1<distnode(k,j)
                    % atualizar distância do nó alvo
                    distnode(k,j) = distnode(partpos(j),j)+1;
                end
                
                % se não houve choque
                if pot(k,partclass(j))>=max(pot(k,:))
                    % muda para nó alvo
                    partpos(j) = k;
                end
            end
            if mod(i,10)==0
                mmpot = mean(max(pot,[],2));
                %disp(sprintf('Iter: %5.0f  Meanpot: %0.4f',i,mmpot))
                if mmpot>maxmmpot
                    maxmmpot = mmpot;
                    stopcnt = 0;
                else    
                    stopcnt = stopcnt + 1;
                    if stopcnt > stopmax
                        break;
                    end
                end
            end
        end
    end
    [~,owner] = max(pot,[],2);
    owndeg = owndeg ./ repmat(sum(owndeg,2),1,options.nclass);
end

